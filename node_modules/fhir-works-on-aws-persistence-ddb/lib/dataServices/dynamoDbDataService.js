"use strict";
/*
 *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *  SPDX-License-Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DynamoDbDataService = void 0;
/* eslint-disable class-methods-use-this */
const v4_1 = __importDefault(require("uuid/v4"));
const fhir_works_on_aws_interface_1 = require("fhir-works-on-aws-interface");
const lodash_1 = require("lodash");
const dynamoDb_1 = require("./dynamoDb");
const dynamoDbBundleService_1 = require("./dynamoDbBundleService");
const dynamoDbUtil_1 = require("./dynamoDbUtil");
const dynamoDbParamBuilder_1 = __importDefault(require("./dynamoDbParamBuilder"));
const dynamoDbHelper_1 = __importDefault(require("./dynamoDbHelper"));
const bulkExport_1 = require("../bulkExport/bulkExport");
const bulkExportS3PresignedUrlGenerator_1 = require("../bulkExport/bulkExportS3PresignedUrlGenerator");
class DynamoDbDataService {
    /**
     * @param dynamoDb - instance of the aws-sdk DynamoDB client
     * @param supportUpdateCreate - Enables update as create. See https://www.hl7.org/fhir/http.html#upsert
     * @param options
     * @param options.enableMultiTenancy - whether or not to enable multi-tenancy. When enabled a tenantId is required for all requests.
     * @param options.bulkExportResultsUrlGenerator - optionally provide an implementation of bulkExportResultsUrlGenerator to override how the bulk export results URLs are generated.
     * This can be useful if you want to serve export results from a file server instead of directly from s3.
     */
    constructor(dynamoDb, supportUpdateCreate = false, { enableMultiTenancy = false, bulkExportResultsUrlGenerator = new bulkExportS3PresignedUrlGenerator_1.BulkExportS3PresignedUrlGenerator(), } = {}) {
        this.MAXIMUM_SYSTEM_LEVEL_CONCURRENT_REQUESTS = 2;
        this.MAXIMUM_CONCURRENT_REQUEST_PER_USER = 1;
        this.dynamoDbHelper = new dynamoDbHelper_1.default(dynamoDb);
        this.transactionService = new dynamoDbBundleService_1.DynamoDbBundleService(dynamoDb, supportUpdateCreate, undefined, {
            enableMultiTenancy,
        });
        this.dynamoDb = dynamoDb;
        this.updateCreateSupported = supportUpdateCreate;
        this.enableMultiTenancy = enableMultiTenancy;
        this.bulkExportResultsUrlGenerator = bulkExportResultsUrlGenerator;
    }
    assertValidTenancyMode(tenantId) {
        if (this.enableMultiTenancy && tenantId === undefined) {
            throw new Error('This instance has multi-tenancy enabled, but the incoming request is missing tenantId');
        }
        if (!this.enableMultiTenancy && tenantId !== undefined) {
            throw new Error('This instance has multi-tenancy disabled, but the incoming request has a tenantId');
        }
    }
    async readResource(request) {
        this.assertValidTenancyMode(request.tenantId);
        return this.dynamoDbHelper.getMostRecentUserReadableResource(request.resourceType, request.id, request.tenantId);
    }
    async vReadResource(request) {
        this.assertValidTenancyMode(request.tenantId);
        const { resourceType, id, vid, tenantId } = request;
        const params = dynamoDbParamBuilder_1.default.buildGetItemParam(id, parseInt(vid, 10), tenantId);
        const result = await this.dynamoDb.getItem(params).promise();
        if (result.Item === undefined) {
            throw new fhir_works_on_aws_interface_1.ResourceVersionNotFoundError(resourceType, id, vid);
        }
        let item = dynamoDb_1.DynamoDBConverter.unmarshall(result.Item);
        if (item.resourceType !== resourceType) {
            throw new fhir_works_on_aws_interface_1.ResourceVersionNotFoundError(resourceType, id, vid);
        }
        item = dynamoDbUtil_1.DynamoDbUtil.cleanItem(item);
        return {
            message: 'Resource found',
            resource: item,
        };
    }
    async createResource(request) {
        this.assertValidTenancyMode(request.tenantId);
        const { resourceType, resource, tenantId } = request;
        return this.createResourceWithId(resourceType, resource, (0, v4_1.default)(), tenantId);
    }
    async createResourceWithId(resourceType, resource, resourceId, tenantId) {
        const regex = new RegExp('^[a-zA-Z0-9-.]{1,64}$');
        if (!regex.test(resourceId)) {
            throw new fhir_works_on_aws_interface_1.InvalidResourceError(`Resource creation failed, id ${resourceId} is not valid`);
        }
        const vid = 1;
        let resourceClone = (0, fhir_works_on_aws_interface_1.clone)(resource);
        resourceClone.resourceType = resourceType;
        const param = dynamoDbParamBuilder_1.default.buildPutAvailableItemParam(resourceClone, resourceId, vid, false, tenantId);
        try {
            await this.dynamoDb.putItem(param).promise();
        }
        catch (e) {
            if (e.code === 'ConditionalCheckFailedException') {
                // It is highly unlikely that an autogenerated id will collide with a preexisting id.
                throw new Error('Resource creation failed, id matches an existing resource');
            }
            throw e;
        }
        const item = dynamoDb_1.DynamoDBConverter.unmarshall(param.Item);
        resourceClone = dynamoDbUtil_1.DynamoDbUtil.cleanItem(item);
        return {
            success: true,
            message: 'Resource created',
            resource: resourceClone,
        };
    }
    async deleteResource(request) {
        this.assertValidTenancyMode(request.tenantId);
        const { resourceType, id, tenantId } = request;
        const itemServiceResponse = await this.readResource({ resourceType, id, tenantId });
        const { versionId } = itemServiceResponse.resource.meta;
        return this.deleteVersionedResource(resourceType, id, parseInt(versionId, 10), tenantId);
    }
    async deleteVersionedResource(resourceType, id, vid, tenantId) {
        const updateStatusToDeletedParam = dynamoDbParamBuilder_1.default.buildUpdateDocumentStatusParam("AVAILABLE" /* AVAILABLE */, "DELETED" /* DELETED */, id, vid, resourceType, tenantId).Update;
        await this.dynamoDb.updateItem(updateStatusToDeletedParam).promise();
        return {
            success: true,
            message: `Successfully deleted ResourceType: ${resourceType}, Id: ${id}, VersionId: ${vid}`,
        };
    }
    async updateResource(request) {
        this.assertValidTenancyMode(request.tenantId);
        const { resource, resourceType, id, tenantId } = request;
        try {
            // Will throw ResourceNotFoundError if resource can't be found
            await this.readResource({ resourceType, id, tenantId });
        }
        catch (e) {
            if (this.updateCreateSupported && (0, fhir_works_on_aws_interface_1.isResourceNotFoundError)(e)) {
                return this.createResourceWithId(resourceType, resource, id, tenantId);
            }
            throw e;
        }
        const resourceClone = (0, fhir_works_on_aws_interface_1.clone)(resource);
        const batchRequest = {
            operation: 'update',
            resourceType,
            id,
            resource: resourceClone,
        };
        // Sending the request to `atomicallyReadWriteResources` to take advantage of LOCKING management handled by
        // that method
        const response = await this.transactionService.transaction({
            requests: [batchRequest],
            startTime: new Date(),
            tenantId,
        });
        const batchReadWriteEntryResponse = response.batchReadWriteResponses[0];
        resourceClone.meta = batchReadWriteEntryResponse.resource.meta;
        return {
            success: true,
            message: 'Resource updated',
            resource: resourceClone,
        };
    }
    async initiateExport(initiateExportRequest) {
        this.assertValidTenancyMode(initiateExportRequest.tenantId);
        await this.throttleExportRequestsIfNeeded(initiateExportRequest.requesterUserId, initiateExportRequest.tenantId);
        // Create new export job
        const exportJob = this.buildExportJob(initiateExportRequest);
        await (0, bulkExport_1.startJobExecution)(exportJob);
        const params = dynamoDbParamBuilder_1.default.buildPutCreateExportRequest(exportJob, initiateExportRequest);
        await this.dynamoDb.putItem(params).promise();
        return exportJob.jobId;
    }
    async throttleExportRequestsIfNeeded(requesterUserId, tenantId) {
        const jobStatusesToThrottle = ['canceling', 'in-progress'];
        const exportJobItems = await this.getJobsWithExportStatuses(jobStatusesToThrottle);
        if (exportJobItems) {
            const numberOfConcurrentUserRequest = exportJobItems.filter((item) => {
                return dynamoDb_1.DynamoDBConverter.unmarshall(item).jobOwnerId === requesterUserId;
            }).length;
            let concurrentTenantRequest = exportJobItems;
            if (tenantId) {
                concurrentTenantRequest = exportJobItems.filter((item) => {
                    return dynamoDb_1.DynamoDBConverter.unmarshall(item).tenantId === tenantId;
                });
            }
            if (numberOfConcurrentUserRequest >= this.MAXIMUM_CONCURRENT_REQUEST_PER_USER ||
                concurrentTenantRequest.length >= this.MAXIMUM_SYSTEM_LEVEL_CONCURRENT_REQUESTS) {
                throw new fhir_works_on_aws_interface_1.TooManyConcurrentExportRequestsError();
            }
        }
    }
    async getJobsWithExportStatuses(jobStatuses) {
        const jobStatusPromises = jobStatuses.map((jobStatus) => {
            const projectionExpression = 'jobOwnerId, jobStatus';
            const queryJobStatusParam = dynamoDbParamBuilder_1.default.buildQueryExportRequestJobStatus(jobStatus, projectionExpression);
            return this.dynamoDb.query(queryJobStatusParam).promise();
        });
        const jobStatusResponses = await Promise.all(jobStatusPromises);
        let allJobStatusItems = [];
        jobStatusResponses.forEach((jobStatusResponse) => {
            if (jobStatusResponse.Items) {
                allJobStatusItems = allJobStatusItems.concat(jobStatusResponse.Items);
            }
        });
        return allJobStatusItems;
    }
    async cancelExport(jobId, tenantId) {
        this.assertValidTenancyMode(tenantId);
        const jobDetailsParam = dynamoDbParamBuilder_1.default.buildGetExportRequestJob(jobId, tenantId);
        const jobDetailsResponse = await this.dynamoDb.getItem(jobDetailsParam).promise();
        if (!jobDetailsResponse.Item) {
            throw new fhir_works_on_aws_interface_1.ResourceNotFoundError('$export', jobId);
        }
        const jobItem = dynamoDb_1.DynamoDBConverter.unmarshall(jobDetailsResponse.Item);
        if (['completed', 'failed'].includes(jobItem.jobStatus)) {
            throw new Error(`Job cannot be canceled because job is already in ${jobItem.jobStatus} state`);
        }
        // A job in the canceled or canceling state doesn't need to be updated to 'canceling'
        if (['canceled', 'canceling'].includes(jobItem.jobStatus)) {
            return;
        }
        const params = dynamoDbParamBuilder_1.default.buildUpdateExportRequestJobStatus(jobId, 'canceling', tenantId);
        await this.dynamoDb.updateItem(params).promise();
    }
    async getExportStatus(jobId, tenantId) {
        this.assertValidTenancyMode(tenantId);
        const jobDetailsParam = dynamoDbParamBuilder_1.default.buildGetExportRequestJob(jobId, tenantId);
        const jobDetailsResponse = await this.dynamoDb.getItem(jobDetailsParam).promise();
        if (!jobDetailsResponse.Item) {
            throw new fhir_works_on_aws_interface_1.ResourceNotFoundError('$export', jobId);
        }
        const item = dynamoDb_1.DynamoDBConverter.unmarshall(jobDetailsResponse.Item);
        const { jobStatus, jobOwnerId, transactionTime, exportType, outputFormat, since, type, groupId, errorArray = [], errorMessage = '', } = item;
        const results = jobStatus === 'completed'
            ? await (0, bulkExport_1.getBulkExportResults)(this.bulkExportResultsUrlGenerator, jobId, tenantId)
            : { requiresAccessToken: undefined, exportedFileUrls: [] };
        const getExportStatusResponse = {
            jobOwnerId,
            jobStatus,
            requiresAccessToken: results.requiresAccessToken,
            exportedFileUrls: results.exportedFileUrls,
            transactionTime,
            exportType,
            outputFormat,
            since,
            type,
            groupId,
            errorArray,
            errorMessage,
        };
        return getExportStatusResponse;
    }
    buildExportJob(initiateExportRequest) {
        var _a, _b, _c, _d;
        const initialStatus = 'in-progress';
        const uuid = (0, v4_1.default)();
        // Combine allowedResourceTypes and user input parameter type before pass to Glue job
        let type = initiateExportRequest.allowedResourceTypes.join(',');
        if (initiateExportRequest.type) {
            // If the types user requested are not a subset of allowed types, reject
            if ((0, lodash_1.difference)(initiateExportRequest.type.split(','), initiateExportRequest.allowedResourceTypes).length !==
                0) {
                throw new fhir_works_on_aws_interface_1.UnauthorizedError('User does not have permission for requested resource type.');
            }
            type = initiateExportRequest.type;
        }
        const exportJob = {
            jobId: uuid,
            jobOwnerId: initiateExportRequest.requesterUserId,
            exportType: initiateExportRequest.exportType,
            groupId: (_a = initiateExportRequest.groupId) !== null && _a !== void 0 ? _a : '',
            serverUrl: (_b = initiateExportRequest.serverUrl) !== null && _b !== void 0 ? _b : '',
            outputFormat: (_c = initiateExportRequest.outputFormat) !== null && _c !== void 0 ? _c : 'ndjson',
            since: (_d = initiateExportRequest.since) !== null && _d !== void 0 ? _d : '1800-01-01T00:00:00.000Z',
            type,
            transactionTime: initiateExportRequest.transactionTime,
            jobStatus: initialStatus,
            jobFailedMessage: '',
        };
        if (this.enableMultiTenancy) {
            exportJob.tenantId = initiateExportRequest.tenantId;
        }
        if (initiateExportRequest.groupId) {
            exportJob.compartmentSearchParamFile =
                initiateExportRequest.fhirVersion === '4.0.1'
                    ? process.env.PATIENT_COMPARTMENT_V4
                    : process.env.PATIENT_COMPARTMENT_V3;
        }
        return exportJob;
    }
    async getActiveSubscriptions(params) {
        var _a;
        this.assertValidTenancyMode(params.tenantId);
        const subscriptionQuery = dynamoDbParamBuilder_1.default.buildGetActiveSubscriptions(params.tenantId);
        let queryResponse;
        const subscriptions = [];
        do {
            // eslint-disable-next-line no-await-in-loop
            queryResponse = await this.dynamoDb.query(subscriptionQuery).promise();
            (_a = queryResponse.Items) === null || _a === void 0 ? void 0 : _a.forEach((response) => {
                const item = dynamoDb_1.DynamoDBConverter.unmarshall(response);
                subscriptions.push(item);
            });
            if (queryResponse.LastEvaluatedKey) {
                subscriptionQuery.ExclusiveStartKey = queryResponse.LastEvaluatedKey;
            }
        } while (queryResponse.LastEvaluatedKey);
        return subscriptions;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    conditionalCreateResource(request, queryParams) {
        throw new Error('Method not implemented.');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    conditionalUpdateResource(request, queryParams) {
        throw new Error('Method not implemented.');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    patchResource(request) {
        throw new Error('Method not implemented.');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    conditionalPatchResource(request, queryParams) {
        throw new Error('Method not implemented.');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    conditionalDeleteResource(request, queryParams) {
        throw new Error('Method not implemented.');
    }
}
exports.DynamoDbDataService = DynamoDbDataService;
//# sourceMappingURL=dynamoDbDataService.js.map