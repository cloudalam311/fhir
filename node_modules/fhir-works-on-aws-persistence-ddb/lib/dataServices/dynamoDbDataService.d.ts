import { BulkDataAccess, ConditionalDeleteResourceRequest, CreateResourceRequest, DeleteResourceRequest, ExportJobStatus, GenericResponse, GetExportStatusResponse, InitiateExportRequest, PatchResourceRequest, Persistence, ReadResourceRequest, UpdateResourceRequest, vReadResourceRequest } from 'fhir-works-on-aws-interface';
import DynamoDB, { ItemList } from 'aws-sdk/clients/dynamodb';
import { BulkExportJob } from '../bulkExport/types';
import { BulkExportResultsUrlGenerator } from '../bulkExport/bulkExportResultsUrlGenerator';
export declare class DynamoDbDataService implements Persistence, BulkDataAccess {
    private readonly MAXIMUM_SYSTEM_LEVEL_CONCURRENT_REQUESTS;
    private readonly MAXIMUM_CONCURRENT_REQUEST_PER_USER;
    readonly updateCreateSupported: boolean;
    readonly enableMultiTenancy: boolean;
    private readonly transactionService;
    private readonly dynamoDbHelper;
    private readonly dynamoDb;
    private readonly bulkExportResultsUrlGenerator;
    /**
     * @param dynamoDb - instance of the aws-sdk DynamoDB client
     * @param supportUpdateCreate - Enables update as create. See https://www.hl7.org/fhir/http.html#upsert
     * @param options
     * @param options.enableMultiTenancy - whether or not to enable multi-tenancy. When enabled a tenantId is required for all requests.
     * @param options.bulkExportResultsUrlGenerator - optionally provide an implementation of bulkExportResultsUrlGenerator to override how the bulk export results URLs are generated.
     * This can be useful if you want to serve export results from a file server instead of directly from s3.
     */
    constructor(dynamoDb: DynamoDB, supportUpdateCreate?: boolean, { enableMultiTenancy, bulkExportResultsUrlGenerator, }?: {
        enableMultiTenancy?: boolean;
        bulkExportResultsUrlGenerator?: BulkExportResultsUrlGenerator;
    });
    private assertValidTenancyMode;
    readResource(request: ReadResourceRequest): Promise<GenericResponse>;
    vReadResource(request: vReadResourceRequest): Promise<GenericResponse>;
    createResource(request: CreateResourceRequest): Promise<{
        success: boolean;
        message: string;
        resource: any;
    }>;
    private createResourceWithId;
    deleteResource(request: DeleteResourceRequest): Promise<{
        success: boolean;
        message: string;
    }>;
    deleteVersionedResource(resourceType: string, id: string, vid: number, tenantId?: string): Promise<{
        success: boolean;
        message: string;
    }>;
    updateResource(request: UpdateResourceRequest): Promise<{
        success: boolean;
        message: string;
        resource: any;
    }>;
    initiateExport(initiateExportRequest: InitiateExportRequest): Promise<string>;
    throttleExportRequestsIfNeeded(requesterUserId: string, tenantId?: string): Promise<void>;
    getJobsWithExportStatuses(jobStatuses: ExportJobStatus[]): Promise<ItemList>;
    cancelExport(jobId: string, tenantId?: string): Promise<void>;
    getExportStatus(jobId: string, tenantId?: string): Promise<GetExportStatusResponse>;
    buildExportJob(initiateExportRequest: InitiateExportRequest): BulkExportJob;
    getActiveSubscriptions(params: {
        tenantId?: string;
    }): Promise<Record<string, any>[]>;
    conditionalCreateResource(request: CreateResourceRequest, queryParams: any): Promise<GenericResponse>;
    conditionalUpdateResource(request: UpdateResourceRequest, queryParams: any): Promise<GenericResponse>;
    patchResource(request: PatchResourceRequest): Promise<GenericResponse>;
    conditionalPatchResource(request: PatchResourceRequest, queryParams: any): Promise<GenericResponse>;
    conditionalDeleteResource(request: ConditionalDeleteResourceRequest, queryParams: any): Promise<GenericResponse>;
}
