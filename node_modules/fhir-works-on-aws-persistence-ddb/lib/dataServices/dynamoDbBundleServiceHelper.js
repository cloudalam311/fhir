"use strict";
/*
 *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *  SPDX-License-Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const v4_1 = __importDefault(require("uuid/v4"));
const dynamoDbUtil_1 = require("./dynamoDbUtil");
const dynamoDb_1 = require("./dynamoDb");
const dynamoDbParamBuilder_1 = __importDefault(require("./dynamoDbParamBuilder"));
const constants_1 = require("../constants");
class DynamoDbBundleServiceHelper {
    static generateStagingRequests(requests, idToVersionId, tenantId) {
        const deleteRequests = [];
        const createRequests = [];
        const updateRequests = [];
        const readRequests = [];
        let newLocks = [];
        let newBundleEntryResponses = [];
        requests.forEach((request) => {
            switch (request.operation) {
                case 'create': {
                    // Add create request, put it in PENDING
                    let id = (0, v4_1.default)();
                    if (request.id) {
                        id = request.id;
                    }
                    const vid = 1;
                    const Item = dynamoDbUtil_1.DynamoDbUtil.prepItemForDdbInsert(request.resource, id, vid, "PENDING" /* PENDING */, tenantId);
                    createRequests.push({
                        Put: {
                            TableName: dynamoDb_1.RESOURCE_TABLE,
                            Item: dynamoDb_1.DynamoDBConverter.marshall(Item),
                        },
                    });
                    const { stagingResponse, itemLocked } = this.addStagingResponseAndItemsLocked(request.operation, {
                        ...request.resource,
                        meta: { ...Item.meta },
                        id,
                    });
                    newBundleEntryResponses = newBundleEntryResponses.concat(stagingResponse);
                    newLocks = newLocks.concat(itemLocked);
                    break;
                }
                case 'update': {
                    // Create new entry with status = PENDING
                    // When updating a resource, create a new Document for that resource
                    const { id } = request.resource;
                    const vid = (idToVersionId[id] || 0) + 1;
                    const Item = dynamoDbUtil_1.DynamoDbUtil.prepItemForDdbInsert(request.resource, id, vid, "PENDING" /* PENDING */, tenantId);
                    updateRequests.push({
                        Put: {
                            TableName: dynamoDb_1.RESOURCE_TABLE,
                            Item: dynamoDb_1.DynamoDBConverter.marshall(Item),
                        },
                    });
                    const { stagingResponse, itemLocked } = this.addStagingResponseAndItemsLocked(request.operation, {
                        ...request.resource,
                        meta: { ...Item.meta },
                    });
                    newBundleEntryResponses = newBundleEntryResponses.concat(stagingResponse);
                    newLocks = newLocks.concat(itemLocked);
                    break;
                }
                case 'delete': {
                    // Mark documentStatus as PENDING_DELETE
                    const { id, resourceType } = request;
                    const vid = idToVersionId[id];
                    deleteRequests.push(dynamoDbParamBuilder_1.default.buildUpdateDocumentStatusParam("LOCKED" /* LOCKED */, "PENDING_DELETE" /* PENDING_DELETE */, id, vid, resourceType, tenantId));
                    newBundleEntryResponses.push({
                        id,
                        vid: vid.toString(),
                        operation: request.operation,
                        lastModified: new Date().toISOString(),
                        resource: {},
                        resourceType: request.resourceType,
                    });
                    break;
                }
                case 'read': {
                    // Read the latest version with documentStatus = "LOCKED"
                    const { id } = request;
                    const vid = idToVersionId[id];
                    readRequests.push({
                        Get: {
                            TableName: dynamoDb_1.RESOURCE_TABLE,
                            Key: dynamoDb_1.DynamoDBConverter.marshall({
                                id: (0, dynamoDbUtil_1.buildHashKey)(id, tenantId),
                                vid,
                            }),
                        },
                    });
                    newBundleEntryResponses.push({
                        id,
                        vid: vid.toString(),
                        operation: request.operation,
                        lastModified: '',
                        resource: {},
                        resourceType: request.resourceType,
                    });
                    break;
                }
                default: {
                    break;
                }
            }
        });
        return {
            deleteRequests,
            createRequests,
            updateRequests,
            readRequests,
            newLocks,
            newStagingResponses: newBundleEntryResponses,
        };
    }
    static generateRollbackRequests(bundleEntryResponses, tenantId) {
        let itemsToRemoveFromLock = [];
        let transactionRequests = [];
        bundleEntryResponses.forEach((stagingResponse) => {
            switch (stagingResponse.operation) {
                case 'create':
                case 'update': {
                    /*
                        DELETE latest record
                        and remove lock entry from lockedItems
                     */
                    const { transactionRequest, itemToRemoveFromLock } = this.generateDeleteLatestRecordAndItemToRemoveFromLock(stagingResponse.resourceType, stagingResponse.id, stagingResponse.vid, tenantId);
                    transactionRequests = transactionRequests.concat(transactionRequest);
                    itemsToRemoveFromLock = itemsToRemoveFromLock.concat(itemToRemoveFromLock);
                    break;
                }
                default: {
                    // For READ and DELETE we don't need to delete anything, because no new records were made for those
                    // requests
                    break;
                }
            }
        });
        return { transactionRequests, itemsToRemoveFromLock };
    }
    static generateDeleteLatestRecordAndItemToRemoveFromLock(resourceType, id, vid, tenantId) {
        const transactionRequest = dynamoDbParamBuilder_1.default.buildDeleteParam(id, parseInt(vid, 10), tenantId);
        const itemToRemoveFromLock = {
            id,
            vid,
            resourceType,
        };
        return { transactionRequest, itemToRemoveFromLock };
    }
    static populateBundleEntryResponseWithReadResult(bundleEntryResponses, readResult) {
        var _a, _b;
        let index = 0;
        const updatedStagingResponses = bundleEntryResponses;
        for (let i = 0; i < bundleEntryResponses.length; i += 1) {
            const stagingResponse = bundleEntryResponses[i];
            // The first readResult will be the response to the first READ stagingResponse
            if (stagingResponse.operation === 'read') {
                let item = (_a = readResult === null || readResult === void 0 ? void 0 : readResult.Responses[index]) === null || _a === void 0 ? void 0 : _a.Item;
                if (item === undefined) {
                    throw new Error('Failed to fulfill all READ requests');
                }
                item = dynamoDb_1.DynamoDBConverter.unmarshall(item);
                item = dynamoDbUtil_1.DynamoDbUtil.cleanItem(item);
                stagingResponse.resource = item;
                stagingResponse.lastModified = ((_b = item === null || item === void 0 ? void 0 : item.meta) === null || _b === void 0 ? void 0 : _b.lastUpdated) ? item.meta.lastUpdated : '';
                updatedStagingResponses[i] = stagingResponse;
                index += 1;
            }
        }
        return updatedStagingResponses;
    }
    static addStagingResponseAndItemsLocked(operation, resource) {
        const stagingResponse = {
            id: resource.id,
            vid: resource.meta.versionId,
            operation,
            lastModified: resource.meta.lastUpdated,
            resourceType: resource.resourceType,
            resource,
        };
        const itemLocked = {
            id: resource.id,
            vid: parseInt(resource.meta.versionId, 10),
            resourceType: resource.resourceType,
            operation,
        };
        if (operation === 'update') {
            itemLocked.isOriginalUpdateItem = false;
        }
        return { stagingResponse, itemLocked };
    }
    static async sortBatchRequests(requests, dynamoDbHelper, tenantId) {
        var _a;
        const deleteRequests = [];
        const createRequests = [];
        const updateRequests = [];
        const batchReadWriteResponses = [];
        let originalRequestIndex = -1;
        // eslint-disable-next-line no-restricted-syntax
        for (const request of requests) {
            originalRequestIndex += 1;
            let vid = 0;
            let { id } = request;
            const { resourceType, operation } = request;
            let item;
            // we need to query to get the VersionID of the resource for non-create operations
            if (operation === 'create') {
                vid = 1;
                id = request.id ? request.id : (0, v4_1.default)();
            }
            else {
                try {
                    // eslint-disable-next-line no-await-in-loop
                    item = await dynamoDbHelper.getMostRecentUserReadableResource(resourceType, id, tenantId);
                    vid = Number((_a = item.resource) === null || _a === void 0 ? void 0 : _a.meta.versionId);
                }
                catch (e) {
                    console.log(`Failed to find resource ${id}`);
                    batchReadWriteResponses.push({
                        id,
                        vid: `${vid}`,
                        operation,
                        resourceType,
                        resource: {},
                        lastModified: '',
                        error: '404 Not Found',
                    });
                    // eslint-disable-next-line no-continue
                    continue;
                }
            }
            switch (operation) {
                case 'create': {
                    item = dynamoDbUtil_1.DynamoDbUtil.prepItemForDdbInsert(request.resource, id, vid, "AVAILABLE" /* AVAILABLE */, tenantId);
                    createRequests.push({
                        PutRequest: {
                            Item: dynamoDb_1.DynamoDBConverter.marshall(item),
                        },
                        originalRequestIndex,
                    });
                    batchReadWriteResponses.push({
                        id,
                        vid: item.meta.versionId,
                        operation: request.operation,
                        lastModified: item.meta.lastUpdated,
                        resourceType,
                        resource: item,
                    });
                    break;
                }
                case 'update': {
                    // increment the vid
                    vid += 1;
                    item = dynamoDbUtil_1.DynamoDbUtil.prepItemForDdbInsert({ ...item === null || item === void 0 ? void 0 : item.resource, ...request.resource }, id, vid, "AVAILABLE" /* AVAILABLE */, tenantId);
                    // we create a new version of the resource with an incremented vid
                    updateRequests.push({
                        PutRequest: {
                            Item: dynamoDb_1.DynamoDBConverter.marshall(item),
                        },
                        originalRequestIndex,
                    });
                    batchReadWriteResponses.push({
                        id,
                        vid: vid.toString(),
                        operation: request.operation,
                        lastModified: item.meta.lastUpdated,
                        resourceType,
                        resource: {},
                    });
                    break;
                }
                case 'delete': {
                    deleteRequests.push({
                        Statement: `
                            UPDATE "${dynamoDb_1.RESOURCE_TABLE}"
                            SET "${dynamoDbUtil_1.DOCUMENT_STATUS_FIELD}" = '${"DELETED" /* DELETED */}'
                            WHERE "id" = '${(0, dynamoDbUtil_1.buildHashKey)(id, tenantId)}' AND "vid" = ${vid}
                        `,
                        originalRequestIndex,
                    });
                    batchReadWriteResponses.push({
                        id,
                        vid: vid.toString(),
                        operation: request.operation,
                        lastModified: new Date().toISOString(),
                        resource: {},
                        resourceType: request.resourceType,
                    });
                    break;
                }
                case 'read': {
                    batchReadWriteResponses.push({
                        id,
                        vid: vid.toString(),
                        operation: request.operation,
                        lastModified: '',
                        resource: item === null || item === void 0 ? void 0 : item.resource,
                        resourceType: request.resourceType,
                    });
                    break;
                }
                default:
                    break;
            }
        }
        // we cannot do deleteRequests nor updateRequests in a batchwriteitem call, since we use the update api instead of delete
        // hence, we will separate these requests and use batchexecuteStatement to update items in a batch (and
        // we know there are no conflicts since there will only be updates running)
        return {
            deleteRequests,
            writeRequests: [...createRequests, ...updateRequests],
            batchReadWriteResponses,
        };
    }
    static async processBatchEditRequests(editRequests, batchReadWriteResponses, dynamoDb) {
        var _a, _b;
        const updatedResponses = batchReadWriteResponses;
        for (let i = 0; i < editRequests.length; i += constants_1.MAX_BATCH_WRITE_ITEMS) {
            const upperLimit = Math.min(i + constants_1.MAX_BATCH_WRITE_ITEMS, editRequests.length);
            const batch = editRequests.slice(i, upperLimit);
            const statements = batch.map((x) => {
                return { PutRequest: x.PutRequest };
            });
            // eslint-disable-next-line no-await-in-loop
            const batchExecuteResponse = await dynamoDb
                .batchWriteItem({
                RequestItems: {
                    [dynamoDb_1.RESOURCE_TABLE]: [...statements],
                },
            })
                .promise();
            (_b = (_a = batchExecuteResponse.UnprocessedItems) === null || _a === void 0 ? void 0 : _a[dynamoDb_1.RESOURCE_TABLE]) === null || _b === void 0 ? void 0 : _b.forEach((item, unprocessedItemIndex) => {
                console.log('Unable to process request: ', item);
                // get the position of the batch element at index in the larger batchReadWriteResponses array
                updatedResponses[batch[unprocessedItemIndex].originalRequestIndex] = {
                    ...batchReadWriteResponses[batch[unprocessedItemIndex].originalRequestIndex],
                    error: `400 Bad Request`, // indicate the request failed due to large size of request
                };
            });
        }
        return updatedResponses;
    }
    static async processBatchDeleteRequests(deleteRequests, batchReadWriteResponses, dynamoDb) {
        var _a;
        const updatedResponses = batchReadWriteResponses;
        for (let i = 0; i < deleteRequests.length; i += constants_1.MAX_BATCH_WRITE_ITEMS) {
            const upperLimit = Math.min(i + constants_1.MAX_BATCH_WRITE_ITEMS, deleteRequests.length);
            const batch = deleteRequests.slice(i, upperLimit);
            const statements = batch.map((x) => {
                return { Statement: x.Statement };
            });
            // eslint-disable-next-line no-await-in-loop
            const batchExecuteResponse = await dynamoDb
                .batchExecuteStatement({
                Statements: [...statements],
            })
                .promise();
            (_a = batchExecuteResponse.Responses) === null || _a === void 0 ? void 0 : _a.forEach((response, index) => {
                if (response.Error) {
                    console.log('Unable to process request: ', response.Error);
                    // get the position of the batch element at index in the larger batchReadWriteResponses array
                    updatedResponses[batch[index].originalRequestIndex] = {
                        ...batchReadWriteResponses[batch[index].originalRequestIndex],
                        error: `${response.Error.Code} ${response.Error.Message}`, // indicate the request failed
                    };
                }
            });
        }
        return updatedResponses;
    }
}
exports.default = DynamoDbBundleServiceHelper;
//# sourceMappingURL=dynamoDbBundleServiceHelper.js.map