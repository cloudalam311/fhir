"use strict";
/*
 *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *  SPDX-License-Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fhir_works_on_aws_interface_1 = require("fhir-works-on-aws-interface");
const dynamoDbParamBuilder_1 = __importDefault(require("./dynamoDbParamBuilder"));
const dynamoDb_1 = require("./dynamoDb");
const dynamoDbUtil_1 = require("./dynamoDbUtil");
class DynamoDbHelper {
    constructor(dynamoDb) {
        this.dynamoDb = dynamoDb;
    }
    async getMostRecentResources(resourceType, id, maxNumberOfVersionsToGet, projectionExpression, tenantId) {
        const params = dynamoDbParamBuilder_1.default.buildGetResourcesQueryParam(id, resourceType, maxNumberOfVersionsToGet, projectionExpression, tenantId);
        let result = {};
        try {
            result = await this.dynamoDb.query(params).promise();
        }
        catch (e) {
            if (e.code === 'ConditionalCheckFailedException') {
                throw new fhir_works_on_aws_interface_1.ResourceNotFoundError(resourceType, id);
            }
            throw e;
        }
        const items = result.Items
            ? result.Items.map((ddbJsonItem) => dynamoDb_1.DynamoDBConverter.unmarshall(ddbJsonItem))
            : [];
        if (items.length === 0) {
            throw new fhir_works_on_aws_interface_1.ResourceNotFoundError(resourceType, id);
        }
        return items;
    }
    async getMostRecentResource(resourceType, id, projectionExpression, tenantId) {
        let item = (await this.getMostRecentResources(resourceType, id, 1, projectionExpression, tenantId))[0];
        item = dynamoDbUtil_1.DynamoDbUtil.cleanItem(item);
        return {
            message: 'Resource found',
            resource: item,
        };
    }
    /**
     * @return The most recent resource that has not been deleted and has been committed to the database (i.e. The resource is not in a transitional state)
     */
    async getMostRecentUserReadableResource(resourceType, id, tenantId) {
        const items = await this.getMostRecentResources(resourceType, id, 2, undefined, tenantId);
        const latestItemDocStatus = items[0][dynamoDbUtil_1.DOCUMENT_STATUS_FIELD];
        if (latestItemDocStatus === "DELETED" /* DELETED */) {
            throw new fhir_works_on_aws_interface_1.ResourceNotFoundError(resourceType, id);
        }
        let item = {};
        // Latest version that are in LOCKED/PENDING_DELETE/AVAILABLE are valid to be read from
        if (["AVAILABLE" /* AVAILABLE */, "PENDING_DELETE" /* PENDING_DELETE */, "LOCKED" /* LOCKED */].includes(latestItemDocStatus)) {
            // eslint-disable-next-line prefer-destructuring
            item = items[0];
        }
        else if (latestItemDocStatus === "PENDING" /* PENDING */ && items.length > 1) {
            // If the latest version of the resource is in PENDING, grab the previous version
            // eslint-disable-next-line prefer-destructuring
            item = items[1];
        }
        else {
            throw new fhir_works_on_aws_interface_1.ResourceNotFoundError(resourceType, id);
        }
        item = dynamoDbUtil_1.DynamoDbUtil.cleanItem(item);
        return {
            message: 'Resource found',
            resource: item,
        };
    }
}
exports.default = DynamoDbHelper;
//# sourceMappingURL=dynamoDbHelper.js.map