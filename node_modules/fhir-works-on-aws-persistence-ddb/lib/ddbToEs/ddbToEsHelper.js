"use strict";
/*
 *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *  SPDX-License-Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-underscore-dangle */
const elasticsearch_1 = require("@elastic/elasticsearch");
// @ts-ignore
const aws_elasticsearch_connector_1 = require("aws-elasticsearch-connector");
const lodash_1 = require("lodash");
const AWS_1 = __importDefault(require("../AWS"));
const dynamoDbUtil_1 = require("../dataServices/dynamoDbUtil");
const loggerBuilder_1 = __importDefault(require("../loggerBuilder"));
const REMOVE = 'REMOVE';
const DELETED = 'DELETED';
const logger = (0, loggerBuilder_1.default)();
const { IS_OFFLINE, ELASTICSEARCH_DOMAIN_ENDPOINT } = process.env;
const formatDocument = (ddbImage) => {
    // eslint-disable-next-line no-underscore-dangle
    if (ddbImage._tenantId) {
        return {
            ...ddbImage,
            // eslint-disable-next-line no-underscore-dangle
            id: ddbImage._id,
            _id: undefined, // _id is a reserved field in ES, so it must be removed.
        };
    }
    return ddbImage;
};
const getDefaultESClientFromEnvVars = () => {
    let ES_DOMAIN_ENDPOINT = ELASTICSEARCH_DOMAIN_ENDPOINT || 'https://fake-es-endpoint.com';
    if (IS_OFFLINE === 'true') {
        const { ACCESS_KEY, SECRET_KEY, AWS_REGION, OFFLINE_ELASTICSEARCH_DOMAIN_ENDPOINT } = process.env;
        AWS_1.default.config.update({
            region: AWS_REGION || 'us-west-2',
            accessKeyId: ACCESS_KEY,
            secretAccessKey: SECRET_KEY,
        });
        ES_DOMAIN_ENDPOINT = OFFLINE_ELASTICSEARCH_DOMAIN_ENDPOINT || 'https://fake-es-endpoint.com';
    }
    return new elasticsearch_1.Client({
        node: ES_DOMAIN_ENDPOINT,
        Connection: aws_elasticsearch_connector_1.AmazonConnection,
        Transport: aws_elasticsearch_connector_1.AmazonTransport,
    });
};
class DdbToEsHelper {
    constructor({ esClient = getDefaultESClientFromEnvVars() } = {}) {
        this.ElasticSearch = esClient;
    }
    // async createIndexAndAliasIfNotExist(resourceTypes: Set<string>) {
    async createIndexAndAliasIfNotExist(aliases) {
        if (aliases.length === 0) {
            return;
        }
        const uniqAliases = (0, lodash_1.uniqWith)(aliases, lodash_1.isEqual);
        const listOfAliases = uniqAliases.map((x) => x.alias);
        const { body: allFound } = await this.ElasticSearch.indices.existsAlias({
            name: listOfAliases,
            expand_wildcards: 'all',
        });
        if (allFound) {
            // All needed aliases exist
            return;
        }
        logger.debug('There are missing aliases');
        const existingIndices = new Set();
        const existingAliases = new Set();
        const { body: indices } = await this.ElasticSearch.indices.getAlias();
        Object.entries(indices).forEach(([indexName, indexBody]) => {
            existingIndices.add(indexName);
            Object.keys(indexBody.aliases).forEach((alias) => {
                existingAliases.add(alias);
            });
        });
        const missingAliases = uniqAliases.filter((x) => !existingAliases.has(x.alias));
        const [aliasesWithExistingIndex, aliasesWithMissingIndex] = (0, lodash_1.partition)(missingAliases, (x) => existingIndices.has(x.index));
        try {
            const promises = [];
            const aliasesByIndex = (0, lodash_1.groupBy)(aliasesWithMissingIndex, 'index');
            Object.entries(aliasesByIndex).forEach(([index, aliasesForIndex]) => {
                const aliasesNames = aliasesForIndex.map((x) => x.alias);
                const aliasesArg = (0, lodash_1.zipObject)(aliasesNames, new Array(aliasesNames.length).fill({}));
                logger.info(`create index ${index} & aliases ${aliasesNames}`);
                const params = {
                    index,
                    body: {
                        mappings: {
                            properties: {
                                id: {
                                    type: 'keyword',
                                    index: true,
                                },
                                resourceType: {
                                    type: 'keyword',
                                    index: true,
                                },
                                _references: {
                                    type: 'keyword',
                                    index: true,
                                },
                                documentStatus: {
                                    type: 'keyword',
                                    index: true,
                                },
                                _tenantId: {
                                    type: 'keyword',
                                    index: true,
                                },
                            },
                        },
                        aliases: aliasesArg,
                    },
                };
                promises.push(this.ElasticSearch.indices.create(params));
            });
            aliasesWithExistingIndex.forEach((alias) => {
                // Create Alias; this block is creating aliases for existing indices
                logger.info(`create alias ${alias.alias} for index ${alias.index}`);
                promises.push(this.ElasticSearch.indices.putAlias({
                    index: alias.index,
                    name: alias.alias,
                }));
            });
            await Promise.all(promises);
        }
        catch (error) {
            logger.error(`Failed to create indices and aliases:`, aliases);
            throw error;
        }
    }
    // eslint-disable-next-line class-methods-use-this
    generateFullId(ddbImage) {
        const { id, vid, _tenantId, _id } = ddbImage;
        if (_tenantId) {
            return `${_tenantId}_${_id}_${vid}`;
        }
        return `${id}_${vid}`;
    }
    // Getting promise params for actual deletion of the record from ES
    createBulkESDelete(ddbResourceImage, alias) {
        const compositeId = this.generateFullId(ddbResourceImage);
        return {
            bulkCommand: [
                {
                    delete: { _index: alias, _id: compositeId },
                },
            ],
            id: compositeId,
            type: 'delete',
        };
    }
    // Getting promise params for inserting a new record or editing a record
    createBulkESUpsert(newImage, alias) {
        // We only perform operations on records with documentStatus === AVAILABLE || DELETED
        if (newImage[dynamoDbUtil_1.DOCUMENT_STATUS_FIELD] !== "AVAILABLE" /* AVAILABLE */ &&
            newImage[dynamoDbUtil_1.DOCUMENT_STATUS_FIELD] !== "DELETED" /* DELETED */) {
            return null;
        }
        let type = 'upsert-DELETED';
        if (newImage[dynamoDbUtil_1.DOCUMENT_STATUS_FIELD] === "AVAILABLE" /* AVAILABLE */) {
            type = 'upsert-AVAILABLE';
        }
        const compositeId = this.generateFullId(newImage);
        return {
            id: compositeId,
            bulkCommand: [
                { update: { _index: alias, _id: compositeId } },
                { doc: formatDocument(newImage), doc_as_upsert: true },
            ],
            type,
        };
    }
    async executeEsCmds(cmds) {
        const bulkCmds = cmds.flatMap((cmd) => {
            return cmd.bulkCommand;
        });
        if (bulkCmds.length === 0) {
            return;
        }
        const listOfIds = cmds.map((cmd) => {
            return cmd.id;
        });
        logger.info(`Starting bulk sync operation on ids: `, listOfIds);
        try {
            const { body: bulkResponse } = await this.ElasticSearch.bulk({
                refresh: 'wait_for',
                body: bulkCmds,
            });
            if (bulkResponse.errors) {
                const erroredDocuments = [];
                // The presence of the `error` key indicates that the operation
                // that we did for the document has failed.
                bulkResponse.items.forEach((action) => {
                    const operation = Object.keys(action)[0];
                    if (action[operation].error) {
                        erroredDocuments.push({
                            status: action[operation].status,
                            error: action[operation].error,
                            index: action[operation]._index,
                            id: action[operation]._id,
                            esOperation: operation,
                        });
                    }
                });
                throw new Error(JSON.stringify(erroredDocuments));
            }
        }
        catch (error) {
            logger.error(`Bulk sync operation failed on ids: `, listOfIds);
            throw error;
        }
    }
    // eslint-disable-next-line class-methods-use-this
    isRemoveResource(record) {
        if (record.eventName === REMOVE) {
            return true;
        }
        return record.dynamodb.NewImage.documentStatus.S === DELETED && process.env.ENABLE_ES_HARD_DELETE === 'true';
    }
}
exports.default = DdbToEsHelper;
//# sourceMappingURL=ddbToEsHelper.js.map